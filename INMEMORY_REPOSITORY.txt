================================================================================
INMEMORY REPOSITORY - ПОДРОБНОЕ ОПИСАНИЕ
================================================================================

ЧТО ЭТО ТАКОЕ:
--------------
InMemoryRepository - это простейшее хранилище данных в оперативной памяти (RAM).
Он реализует паттерн Repository, который абстрагирует доступ к данным.

Расположение: theater_sched/repositories/memory.py


================================================================================
СТРУКТУРА И РЕАЛИЗАЦИЯ
================================================================================

1. ВНУТРЕННЕЕ ХРАНИЛИЩЕ:
   ---------------------
   При создании экземпляра InMemoryRepository создаются два словаря (Dict):
   
   - self._scenarios: Dict[str, Scenario]
     * Ключ: scenario_id (строка, UUID сценария)
     * Значение: объект Scenario со всеми данными сценария
     * Хранит: постановки, сцены, таймслоты, людей, роли, ограничения и т.д.
   
   - self._results: Dict[str, ScenarioResult]
     * Ключ: scenario_id (строка, UUID сценария)
     * Значение: объект ScenarioResult с результатами решения
     * Хранит: расписание, назначения людей, значение целевой функции, статус

2. МЕТОДЫ РЕПОЗИТОРИЯ:
   --------------------
   
   a) save_scenario(scenario: Scenario) -> None
      - Сохраняет или обновляет сценарий в словаре _scenarios
      - Использует scenario.id как ключ
      - Если сценарий с таким ID уже существует, он перезаписывается
      - НЕ сохраняет данные на диск, только в RAM
   
   b) get_scenario(scenario_id: str) -> Optional[Scenario]
      - Возвращает сценарий по его ID
      - Если сценарий не найден, возвращает None
      - Не создает копию - возвращает ссылку на объект
   
   c) save_result(result: ScenarioResult) -> None
      - Сохраняет результат решения в словарь _results
      - Использует result.scenario_id как ключ
      - Если результат для этого сценария уже существует, он перезаписывается
      - НЕ сохраняет данные на диск, только в RAM
   
   d) get_result(scenario_id: str) -> Optional[ScenarioResult]
      - Возвращает результат решения по ID сценария
      - Если результат не найден, возвращает None
      - Не создает копию - возвращает ссылку на объект


================================================================================
ИСПОЛЬЗОВАНИЕ В ПРОЕКТЕ
================================================================================

1. СОЗДАНИЕ ЭКЗЕМПЛЯРА:
   --------------------
   В файле theater_sched/api/main.py (строка 158):
   
   repo = InMemoryRepository()
   
   Это глобальный экземпляр, создается один раз при запуске приложения.
   Все API endpoints используют этот же экземпляр.

2. ПЕРЕДАЧА В СЕРВИС:
   -------------------
   В файле theater_sched/api/main.py (строка 159):
   
   svc = ScenarioService(repo)
   
   ScenarioService получает репозиторий через конструктор и сохраняет его
   в self._repo для дальнейшего использования.

3. ИСПОЛЬЗОВАНИЕ В СЦЕНАРИЯХ:
   ---------------------------
   
   a) Создание сценария (ScenarioService.create_scenario):
      - Создает объект Scenario
      - Вызывает repo.save_scenario(scenario) для сохранения
      - Возвращает созданный сценарий
   
   b) Решение сценария (ScenarioService.solve):
      - Получает сценарий: scenario = repo.get_scenario(scenario_id)
      - Обновляет статус: scenario.status = "solving"
      - Сохраняет: repo.save_scenario(scenario)
      - Запускает решатель
      - Сохраняет результат: repo.save_result(result)
      - Обновляет статус: scenario.status = "solved"
      - Сохраняет: repo.save_scenario(scenario)
   
   c) Получение расписания (ScenarioService.get_schedule):
      - Получает результат: result = repo.get_result(scenario_id)
      - Преобразует в словарь и возвращает

4. ПРЯМОЕ ИСПОЛЬЗОВАНИЕ В API:
   ----------------------------
   В некоторых местах API напрямую обращается к репозиторию:
   
   - repo.get_scenario(scenario_id) - для получения сценария
   - repo.save_scenario(scenario) - для сохранения изменений
   - repo.get_result(scenario_id) - для получения результатов
   - repo.save_result(result) - для сохранения результатов


================================================================================
ЖИЗНЕННЫЙ ЦИКЛ ДАННЫХ
================================================================================

1. СОЗДАНИЕ СЦЕНАРИЯ:
   -------------------
   POST /scenarios
   ↓
   API создает сценарий через svc.create_scenario()
   ↓
   ScenarioService создает объект Scenario с UUID
   ↓
   repo.save_scenario(scenario) - сохраняет в _scenarios[scenario_id]
   ↓
   Сценарий доступен в памяти до перезапуска сервера

2. РЕШЕНИЕ СЦЕНАРИЯ:
   ------------------
   POST /scenarios/{id}/solve
   ↓
   API вызывает svc.solve(scenario_id)
   ↓
   ScenarioService получает: scenario = repo.get_scenario(scenario_id)
   ↓
   Обновляет статус: scenario.status = "solving"
   ↓
   repo.save_scenario(scenario) - обновляет в _scenarios
   ↓
   Запускает решатель: result = solver.solve(scenario)
   ↓
   Сохраняет результат: repo.save_result(result) - в _results[scenario_id]
   ↓
   Обновляет статус: scenario.status = "solved"
   ↓
   repo.save_scenario(scenario) - обновляет в _scenarios

3. ПОЛУЧЕНИЕ РАСПИСАНИЯ:
   ----------------------
   GET /scenarios/{id}/schedule
   ↓
   API вызывает svc.get_schedule(scenario_id)
   ↓
   ScenarioService получает: result = repo.get_result(scenario_id)
   ↓
   Преобразует в словарь и возвращает

4. УДАЛЕНИЕ ДАННЫХ:
   -----------------
   Данные удаляются ТОЛЬКО при:
   - Перезапуске сервера (все данные теряются)
   - Перезаписи (новый save_scenario/save_result перезаписывает старые данные)
   - Завершении процесса Python


================================================================================
ОСОБЕННОСТИ И ОГРАНИЧЕНИЯ
================================================================================

1. ВОЛАТИЛЬНОСТЬ ДАННЫХ:
   ----------------------
   ❌ Все данные хранятся только в оперативной памяти
   ❌ При перезапуске сервера ВСЕ данные теряются
   ❌ Нет персистентности - данные не сохраняются на диск
   ❌ Нет резервного копирования
   
   ✅ Быстрый доступ к данным (нет I/O операций)
   ✅ Простая реализация
   ✅ Подходит для разработки и тестирования

2. ОДИН ЭКЗЕМПЛЯР НА ВСЕ ПРИЛОЖЕНИЕ:
   ----------------------------------
   ❌ Все пользователи работают с одним и тем же хранилищем
   ❌ Нет изоляции данных между пользователями
   ❌ Если один пользователь создаст сценарий, он будет виден всем
   ❌ Нет поддержки множественных экземпляров сервера (нет синхронизации)
   
   ✅ Простота использования
   ✅ Нет проблем с синхронизацией (один процесс)

3. ОТСУТСТВИЕ БЛОКИРОВОК:
   -----------------------
   ❌ Нет механизма блокировок для конкурентного доступа
   ❌ Если два запроса одновременно изменяют один сценарий, возможны конфликты
   ❌ Нет транзакций - изменения применяются сразу
   
   ✅ Быстрая работа (нет накладных расходов на блокировки)
   ✅ Простая реализация

4. ОГРАНИЧЕНИЯ ПАМЯТИ:
   --------------------
   ❌ Все данные должны помещаться в RAM сервера
   ❌ При большом количестве сценариев может закончиться память
   ❌ Нет механизма очистки старых данных
   
   ✅ Быстрый доступ (данные в памяти)
   ✅ Нет ограничений на размер (кроме RAM)

5. ОТСУТСТВИЕ ПОИСКА И ФИЛЬТРАЦИИ:
   ---------------------------------
   ❌ Нет методов для поиска сценариев по критериям
   ❌ Нет методов для получения списка всех сценариев
   ❌ Нет методов для удаления сценариев
   ❌ Нет методов для подсчета количества сценариев
   
   ✅ Простая реализация
   ✅ Быстрый доступ по ID


================================================================================
ПРОБЛЕМЫ, КОТОРЫЕ МОГУТ ВОЗНИКНУТЬ
================================================================================

1. ПОТЕРЯ ДАННЫХ ПРИ ПЕРЕЗАПУСКЕ:
   -------------------------------
   Проблема: При перезапуске сервера все сценарии и результаты теряются.
   
   Симптомы:
   - После перезапуска сервера старые сценарии недоступны
   - Фронтенд не может загрузить расписание для существующего scenario_id
   - Ошибка "Scenario not found" для ранее созданных сценариев
   
   Решение:
   - Использовать персистентное хранилище (БД, файлы)
   - Или принимать потерю данных как особенность демо-версии

2. КОНФЛИКТЫ ПРИ КОНКУРЕНТНОМ ДОСТУПЕ:
   ------------------------------------
   Проблема: Если два запроса одновременно изменяют один сценарий.
   
   Симптомы:
   - Потеря изменений (последний запрос перезаписывает изменения первого)
   - Некорректное состояние данных
   - Непредсказуемое поведение
   
   Решение:
   - Добавить блокировки (threading.Lock)
   - Или использовать БД с транзакциями

3. ПРОБЛЕМА С УДАЛЕННЫМ API:
   --------------------------
   Проблема: На удаленном сервере может быть несколько экземпляров приложения
   или перезапуски, что приводит к потере данных.
   
   Симптомы:
   - Сценарий создается, но при следующем запросе не находится
   - Результаты решения теряются
   - Непредсказуемое поведение
   
   Решение:
   - Использовать персистентное хранилище (БД)
   - Или использовать shared storage (Redis, файловая система)

4. УТЕЧКА ПАМЯТИ:
   ---------------
   Проблема: Старые сценарии и результаты накапливаются в памяти.
   
   Симптомы:
   - Память сервера постоянно растет
   - Сервер может упасть из-за нехватки памяти
   - Медленная работа при большом количестве данных
   
   Решение:
   - Добавить механизм очистки старых данных
   - Или использовать БД с автоматической очисткой
   - Или ограничить количество хранимых сценариев

5. ОТСУТСТВИЕ ИСТОРИИ:
   -------------------
   Проблема: Нет возможности посмотреть историю изменений сценария.
   
   Симптомы:
   - Нельзя откатить изменения
   - Нельзя посмотреть, что было изменено
   - Нет аудита изменений
   
   Решение:
   - Использовать БД с версионированием
   - Или добавить логирование изменений


================================================================================
АЛЬТЕРНАТИВЫ И МИГРАЦИЯ
================================================================================

1. БАЗА ДАННЫХ (РЕКОМЕНДУЕТСЯ):
   -----------------------------
   Заменить InMemoryRepository на репозиторий, работающий с БД:
   
   - PostgreSQL - для продакшна (надежность, ACID транзакции)
   - SQLite - для небольших проектов (простота, файловая БД)
   - MongoDB - для документ-ориентированного хранения
   
   Преимущества:
   ✅ Персистентность данных
   ✅ Масштабируемость
   ✅ Транзакции и блокировки
   ✅ Резервное копирование
   ✅ Поиск и фильтрация
   
   Недостатки:
   ❌ Сложнее реализация
   ❌ Требуется настройка БД
   ❌ Медленнее доступ (I/O операции)

2. ФАЙЛОВОЕ ХРАНИЛИЩЕ:
   --------------------
   Сохранять данные в JSON файлы:
   
   - Каждый сценарий - отдельный файл
   - Или один файл со всеми сценариями
   
   Преимущества:
   ✅ Простота реализации
   ✅ Персистентность
   ✅ Легко делать бэкапы
   
   Недостатки:
   ❌ Проблемы с конкурентным доступом
   ❌ Медленнее, чем in-memory
   ❌ Нет транзакций

3. REDIS:
   -------
   Использовать Redis как хранилище:
   
   Преимущества:
   ✅ Быстрый доступ (in-memory, но персистентный)
   ✅ Поддержка множественных экземпляров
   ✅ TTL для автоматической очистки
   
   Недостатки:
   ❌ Требуется отдельный сервис
   ❌ Ограничения на размер данных


================================================================================
РЕКОМЕНДАЦИИ ПО УЛУЧШЕНИЮ
================================================================================

1. ДОБАВИТЬ МЕТОДЫ:
   ----------------
   - list_scenarios() -> List[str] - список всех scenario_id
   - delete_scenario(scenario_id: str) - удаление сценария
   - count_scenarios() -> int - количество сценариев
   - clear_all() - очистка всех данных (для тестирования)

2. ДОБАВИТЬ БЛОКИРОВКИ:
   ---------------------
   Использовать threading.Lock для защиты от конкурентного доступа:
   
   from threading import Lock
   
   class InMemoryRepository:
       def __init__(self):
           self._lock = Lock()
           self._scenarios = {}
           self._results = {}
       
       def save_scenario(self, scenario):
           with self._lock:
               self._scenarios[scenario.id] = scenario

3. ДОБАВИТЬ ЛОГИРОВАНИЕ:
   ----------------------
   Логировать все операции для отладки:
   
   import logging
   logger = logging.getLogger(__name__)
   
   def save_scenario(self, scenario):
       logger.info(f"Saving scenario {scenario.id}")
       self._scenarios[scenario.id] = scenario

4. ДОБАВИТЬ TTL (TIME TO LIVE):
   -----------------------------
   Автоматически удалять старые сценарии:
   
   from datetime import datetime, timedelta
   
   def cleanup_old_scenarios(self, max_age_hours=24):
       cutoff = datetime.now() - timedelta(hours=max_age_hours)
       # Удалить сценарии старше max_age_hours

5. ДОБАВИТЬ ИНТЕРФЕЙС:
   -------------------
   Создать абстрактный базовый класс для репозитория:
   
   from abc import ABC, abstractmethod
   
   class Repository(ABC):
       @abstractmethod
       def save_scenario(self, scenario): pass
       
       @abstractmethod
       def get_scenario(self, scenario_id): pass
   
   Это позволит легко заменить InMemoryRepository на другую реализацию.


================================================================================
ЗАКЛЮЧЕНИЕ
================================================================================

InMemoryRepository - это простое и быстрое решение для разработки и демо.
Однако для продакшна необходимо использовать персистентное хранилище (БД).

Основные проблемы текущей реализации:
- Потеря данных при перезапуске
- Отсутствие изоляции между пользователями
- Отсутствие блокировок для конкурентного доступа
- Накопление данных в памяти без очистки

Рекомендуется:
1. Для разработки - оставить InMemoryRepository
2. Для продакшна - заменить на репозиторий с БД (PostgreSQL/SQLite)
3. Добавить интерфейс Repository для легкой замены реализации

================================================================================



