================================================================================
ОБЩАЯ СИСТЕМА
================================================================================
Назначение: планирование показов Большого театра через веб-интерфейс, REST API и
CP-SAT солвер. Пользователь задаёт сцены, людей, роли, фиксированные назначения
и таймслоты, запускает оптимизацию и смотрит результат.

Слои:
1) Frontend: SPA в `web/app.js` + `web/index.html`.
2) Backend API: FastAPI-сервис в `theater_sched/api/main.py`.
3) Solver: модель OR-Tools CP-SAT в `theater_sched/solver/cp_sat_solver.py`.
4) Repository: in-memory-хранилище сценариев и сущностей.

Поток данных (нормальный кейс):
- Фронт собирает payload сценария -> POST /scenarios.
- Бэк нормализует даты/часы -> сохраняет сценарий -> отдаёт id/status.
- Фронт шлёт POST /scenarios/{id}/solve с constraints.
- Бэк запускает CP-SAT -> обновляет статус/целевое значение.
- Фронт запрашивает GET /scenarios/{id}/gantt и /schedule -> рендерит UI.

================================================================================
ФРОНТЕНД (web/app.js)
================================================================================
Точка входа: `index.html` грузит `app.js`.
Состояние и конфигурация:
- Базовый URL API хранится в localStorage; `getApiBaseUrl()` инициализирует
  `API_BASE_URL`. В UI можно сохранить свой URL.

Дата/время хелперы:
- `parseIsoLike()` парсит YYYY-MM-DD как UTC полночь или падает обратно на Date.
- `getMoscowDayOfWeek()` через Intl.DateTimeFormat (Europe/Moscow) выравнивает DOW.

Создание сценария:
- `compilePayload()` фильтрует/нормализует таймслоты (stage_id, date, day_of_week,
  start_time) и фиксированные назначения.
- `createScenario()` валидирует данные UI, собирает payload, шлёт POST `/scenarios`.

Решение:
- `solveScenario()` отправляет POST `/scenarios/{id}/solve` с optional constraints.

Отрисовка расписания:
- `loadSchedule()` тянет данные для Ганта `/gantt` и подробности `/schedule`,
  затем рисует задачи и назначения.
- `formatDate()` / `formatTime()` форматируют ISO-строки в московском поясе.

Прочее важное:
- Генераторы календаря вычисляют day_of_week в московском поясе.
- Все сетевые вызовы строят URL на базе `API_BASE_URL`.

================================================================================
БЭКЕНД API (theater_sched/api/main.py)
================================================================================
Стек: FastAPI + pydantic, синхронные хендлеры.
Часовой пояс: `MOSCOW_TZ = pytz.timezone("Europe/Moscow")` для нормализации и ISO.

Хелперы нормализации:
- `_normalize_date_and_dow(date_str, dow)` -> локализует дату, возвращает
  (iso_date, weekday 0=Пн..6=Вс).
- `_normalize_timeslot()` и `_normalize_fixed_assignment()` используют это.
- `to_iso(date, hh:mm)` строит TZ-aware ISO для задач Ганта.

Эндпоинты:
- POST `/scenarios`: нормализует таймслоты и фиксированные назначения, создаёт
  сценарий в репо, отдаёт id/status.
- POST `/scenarios/{id}/solve`: опционально обновляет constraints, вызывает солвер,
  возвращает status/objective.
- GET `/scenarios/{id}/gantt`: конвертирует расписание в задачи с ISO-временем.
- GET `/scenarios/{id}/schedule`: отдаёт сырое расписание и назначения.

Сервисы и репозиторий:
- `svc` координирует репозиторий и солвер.
- Репозиторий in-memory; данные теряются при рестарте процесса.

================================================================================
СОЛВЕР (theater_sched/solver/cp_sat_solver.py)
================================================================================
Стек: OR-Tools CP-SAT.
Вход: нормализованный сценарий (таймслоты, роли, люди, ограничения).
Ключевая логика:
- Сортирует таймслоты по (date, start_time).
- `get_week_key()` локализует даты в МСК, группирует по ISO-неделе и сцене.
- Собирает ограничения по назначениям и доступности; оптимизирует целевую функцию.
Выход: расписание, назначения, статус, objective value, сохраняемые в репо.

================================================================================
ДЕПЛОЙ / КОНФИГ
================================================================================
- `render.yaml`, `DEPLOY.md`, `QUICK_DEPLOY.md` описывают выкладку на Render.
- Конфиг клиента опирается на API base URL из окружения (через localStorage).
- БД нет; состояние сервера эфемерно.

================================================================================
ИЗВЕСТНЫЕ РИСКИ / СЛАБЫЕ МЕСТА
================================================================================
- Разница в дне недели: JS getDay() (0=Вс) vs Python weekday() (0=Пн).
- Неоднозначный парсинг дат: фронт создаёт UTC-полночь, бэк парсит naive datetime
  до локализации TZ.
- Обработка ISO: бэк отдаёт TZ-aware строки, фронт должен корректно парсить +03:00.
- In-memory репо: данные теряются при рестарте; одна процессная модель.

================================================================================
ЧТО УЛУЧШИТЬ (моё мнение)
================================================================================
- Унифицировать даты/DOW: передавать канонический YYYY-MM-DD и считать DOW на
  сервере; добавить контрактные тесты на крайние даты и TZ-сдвиги.
- Усилить персистентность: перейти с in-memory на БД (например, Postgres) с
  миграциями и версионированием сценариев; добавить request-id для трассировки.
- Валидация и схемы: расширить pydantic-валидацию диапазонов времени, ролей,
  мощностей; отзеркалить схему на фронте.
- Наблюдаемость солвера: структурные логи и метрики (длительность solve,
  objective, число ограничений); дать dry-run/diagnostics endpoint.
- Робастность фронта: централизованный API-клиент с единой обработкой ошибок и
  retry/backoff для временных сбоёв.
- Тестирование: интеграционные тесты полного цикла (create -> solve -> fetch Gantt)
  и property-тесты нормализации дат/времени.

