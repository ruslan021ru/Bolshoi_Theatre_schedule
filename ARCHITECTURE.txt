================================================================================
АРХИТЕКТУРА ПРОЕКТА И КЛЮЧЕВЫЕ ТОЧКИ ВЗАИМОДЕЙСТВИЯ
================================================================================

ОБЩАЯ СТРУКТУРА:
-----------------
Frontend (web/app.js) <--HTTP--> Backend API (theater_sched/api/main.py)
                                        |
                                        v
                            Solver (theater_sched/solver/cp_sat_solver.py)
                                        |
                                        v
                            Repository (InMemoryRepository)


================================================================================
РАБОТА С API URL
================================================================================

1. ИНИЦИАЛИЗАЦИЯ API URL (web/app.js, строки 35-48):
   - Функция getApiBaseUrl() получает URL из localStorage
   - Если нет в localStorage, проверяет hostname:
     * localhost/127.0.0.1 -> 'http://localhost:8000'
     * Иначе -> пустая строка (пользователь должен указать вручную)
   - Переменная API_BASE_URL хранит текущий URL

2. СОХРАНЕНИЕ API URL (web/app.js, строки 60-86):
   - Пользователь вводит URL в поле apiBaseUrlInput
   - При клике на btnSaveApiUrl:
     * Валидирует URL
     * Сохраняет в localStorage.setItem('api_base_url', cleanUrl)
     * Обновляет переменную API_BASE_URL

3. ВСЕ МЕСТА ИСПОЛЬЗОВАНИЯ API_BASE_URL:
   - Строка 2737: POST /scenarios (создание сценария)
   - Строка 2804: POST /scenarios/{id}/solve (решение)
   - Строка 2902: GET /scenarios/{id}/gantt (получение расписания для Ганта)
   - Строка 2923: GET /scenarios/{id}/schedule (получение расписания)
   - Строка 1837: GET /scenarios/{id}/roles
   - Строка 1852: GET /scenarios/{id}/people
   - Строка 1867: GET /scenarios/{id}/person-production-roles
   - Строка 1882: GET /scenarios/{id}/assignments
   - Строка 1999: PUT /scenarios/{id}/assignments
   - Строка 2121: PUT /scenarios/{id}/assignments
   - Строка 2971: GET /scenarios/{id}/gantt (обновление)
   - Строка 3926: GET /scenarios/{id}/gantt (обновление)
   - Строка 4084: GET /scenarios/{id}/gantt (обновление)


================================================================================
ПОТОК ДАННЫХ: СОЗДАНИЕ СЦЕНАРИЯ
================================================================================

ШАГ 1: ФРОНТЕНД - Подготовка данных (web/app.js)
-------------------------------------------------
Функция: compilePayload() (строки 2615-2708)

1.1. Обработка таймслотов (строки 2628-2676):
    - Фильтрует таймслоты: t.stage_id && t.date
    - Для каждого таймслота:
      * Вычисляет day_of_week через getMoscowDayOfWeek(t.date) (строка 2635)
      * Форматирует дату в YYYY-MM-DD (строки 2644-2666)
      * Возвращает объект: {id, stage_id, date, day_of_week, start_time}

1.2. Функция getMoscowDayOfWeek() (строки 25-33):
    - Парсит дату через parseIsoLike()
    - Использует Intl.DateTimeFormat с timeZone: 'Europe/Moscow'
    - Преобразует JS day (0=ВС) в формат (0=ПН, 6=ВС)

1.3. Функция parseIsoLike() (строки 7-15):
    - Если формат YYYY-MM-DD -> создаёт Date с T00:00:00Z (UTC)
    - Иначе парсит как есть через new Date()

ШАГ 2: ФРОНТЕНД - Отправка запроса (web/app.js)
-------------------------------------------------
Функция: createScenario() (строки 2710-2795)

2.1. Валидация (строка 2713):
    - Вызывает validate() для проверки данных

2.2. Компиляция payload (строка 2719):
    - Вызывает compilePayload()

2.3. Отправка POST запроса (строки 2737-2746):
    - URL: `${API_BASE_URL}/scenarios`
    - Method: POST
    - Headers: {'Content-Type': 'application/json'}
    - Body: JSON.stringify(payload)

ШАГ 3: БЭКЕНД - Приём запроса (theater_sched/api/main.py)
----------------------------------------------------------
Эндпоинт: POST /scenarios (строки 172-189)

3.1. Нормализация таймслотов (строка 176):
    - Вызывает _normalize_timeslot(t) для каждого таймслота

3.2. Функция _normalize_timeslot() (строки 30-40):
    - Вызывает _normalize_date_and_dow(ts.date, ts.day_of_week)
    - Возвращает нормализованный словарь

3.3. Функция _normalize_date_and_dow() (строки 15-27):
    - Парсит дату: datetime.fromisoformat(base_date_str)
    - Локализует в МСК: MOSCOW_TZ.localize(naive_dt)
    - Возвращает: (date.isoformat(), weekday())
    - weekday(): 0=ПН, 6=ВС

3.4. Нормализация fixed_assignments (строка 177):
    - Вызывает _normalize_fixed_assignment(fa) для каждого

3.5. Создание сценария (строки 178-188):
    - Вызывает svc.create_scenario() с нормализованными данными
    - Возвращает: {"scenario_id": s.id, "status": s.status}


================================================================================
ПОТОК ДАННЫХ: РЕШЕНИЕ СЦЕНАРИЯ
================================================================================

ШАГ 1: ФРОНТЕНД - Запрос решения (web/app.js)
-----------------------------------------------
Функция: solveScenario() (строки 2797-2835)

1.1. Отправка POST запроса (строки 2804-2815):
    - URL: `${API_BASE_URL}/scenarios/${scenarioId}/solve`
    - Method: POST
    - Body: JSON.stringify({ constraints: getConstraints() })

ШАГ 2: БЭКЕНД - Решение (theater_sched/api/main.py)
----------------------------------------------------
Эндпоинт: POST /scenarios/{scenario_id}/solve (строки 197-229)

2.1. Обновление constraints (если переданы) (строки 205-222)

2.2. Запуск решателя (строка 224):
    - Вызывает svc.solve(scenario_id)

2.3. Решатель (theater_sched/solver/cp_sat_solver.py):
    - Использует таймслоты из сценария (уже нормализованные)
    - Функция get_week_key() (строки 169-187):
      * Парсит дату через datetime.fromisoformat()
      * Локализует в МСК: MOSCOW_TZ.localize(naive_dt)
      * Вычисляет ISO week через isocalendar()
    - Группирует выходные слоты по неделе и сцене (строки 189-193)

2.4. Возврат результата (строки 225-229):
    - {"scenario_id", "status", "objective_value"}


================================================================================
ПОТОК ДАННЫХ: ПОЛУЧЕНИЕ РАСПИСАНИЯ
================================================================================

ШАГ 1: ФРОНТЕНД - Запрос расписания (web/app.js)
--------------------------------------------------
Функция: loadSchedule() (строки 2895-2980)

1.1. Запрос данных для Ганта (строки 2902-2920):
    - URL: `${API_BASE_URL}/scenarios/${scenarioId}/gantt`
    - Method: GET
    - Получает: {tasks: [{id, resource, start, end, title}]}

1.2. Запрос расписания (строки 2923-2928):
    - URL: `${API_BASE_URL}/scenarios/${scenarioId}/schedule`
    - Method: GET
    - Получает: {schedule: [...], assignments: [...]}

ШАГ 2: БЭКЕНД - Формирование расписания (theater_sched/api/main.py)
---------------------------------------------------------------------
Эндпоинт: GET /scenarios/{scenario_id}/gantt (строки 257-315)

2.1. Получение данных (строки 265-268):
    - schedule_data = svc.get_schedule(scenario_id)
    - s = repo.get_scenario(scenario_id)

2.2. Функция to_iso() (строки 273-282):
    - Принимает: date_str (YYYY-MM-DD), hm (HH:MM)
    - Создаёт: datetime.fromisoformat(f"{date_str}T{time_str}")
    - Локализует: MOSCOW_TZ.localize(naive_dt)
    - Возвращает: moscow_dt.isoformat() (с часовым поясом, например: "2025-11-01T19:00:00+03:00")

2.3. Формирование tasks (строки 284-310):
    - Для каждого элемента расписания:
      * Находит таймслот по ID
      * Вычисляет start через to_iso(tslot.date, tslot.start_time)
      * Вычисляет end = start + 3 часа
      * Формирует объект: {id, resource, start, end, title}

ШАГ 3: ФРОНТЕНД - Отображение (web/app.js)
-------------------------------------------
Функции форматирования:

3.1. formatTime() (строки 2867-2880):
    - Парсит ISO строку через parseIsoLike()
    - Использует Intl.DateTimeFormat с timeZone: 'Europe/Moscow'
    - Возвращает: "HH:MM"

3.2. formatDate() (строки 2882-2892):
    - Парсит ISO строку через parseIsoLike()
    - Использует Intl.DateTimeFormat с timeZone: 'Europe/Moscow'
    - Возвращает: "дд месяц" (например, "1 ноя")


================================================================================
КРИТИЧЕСКИЕ МОМЕНТЫ ДЛЯ ОТЛАДКИ
================================================================================

1. ПРОБЛЕМА: day_of_week вычисляется по-разному на фронте и бэке
   - Фронт: getMoscowDayOfWeek() использует Intl.DateTimeFormat
   - Бэк: _normalize_date_and_dow() использует pytz + weekday()
   - РАЗНИЦА: weekday() в Python возвращает 0=ПН, 6=ВС
   - РАЗНИЦА: getDay() в JS возвращает 0=ВС, 6=СБ
   - ПРОВЕРКА: Сравнить результаты для одной и той же даты

2. ПРОБЛЕМА: Дата может парситься в разных часовых поясах
   - Фронт: parseIsoLike() для YYYY-MM-DD создаёт Date с T00:00:00Z
   - Бэк: datetime.fromisoformat() создаёт naive datetime
   - РАЗНИЦА: Если сервер в другом часовом поясе, naive datetime может интерпретироваться по-разному
   - ПРОВЕРКА: Логировать даты до и после нормализации

3. ПРОБЛЕМА: ISO формат времени может быть разным
   - Бэк возвращает: "2025-11-01T19:00:00+03:00" (с часовым поясом)
   - Фронт парсит через parseIsoLike() -> new Date()
   - ПРОВЕРКА: Убедиться, что фронт правильно обрабатывает +03:00

4. ПРОБЛЕМА: Генерация календаря может создавать таймслоты с неправильным day_of_week
   - Функция generateMonthCalendar() (строки 799-882)
   - Использует getMoscowDayOfWeek() для вычисления dow
   - ПРОВЕРКА: Убедиться, что все таймслоты имеют правильный day_of_week

5. ПРОБЛЕМА: Сортировка таймслотов может зависеть от часового пояса
   - В солвере: sorted(key=lambda ts: (ts.date, ts.start_time)) (строка 119)
   - ПРОВЕРКА: Убедиться, что даты в формате YYYY-MM-DD (лексикографическая сортировка)


================================================================================
РЕКОМЕНДАЦИИ ПО ОТЛАДКЕ
================================================================================

1. ДОБАВИТЬ ЛОГИРОВАНИЕ:
   - В compilePayload(): console.log('Payload timeslots:', JSON.stringify(timeslots))
   - В _normalize_timeslot(): print(f"Normalized: {norm_date}, dow={norm_dow}")
   - В to_iso(): print(f"ISO: {date_str} {hm} -> {iso_str}")

2. ПРОВЕРИТЬ КОНСИСТЕНТНОСТЬ:
   - Сравнить day_of_week на фронте и бэке для одной даты
   - Проверить, что все даты в формате YYYY-MM-DD
   - Убедиться, что ISO строки содержат часовой пояс

3. ПРОВЕРИТЬ СЕТЕВЫЕ ЗАПРОСЫ:
   - Открыть DevTools -> Network
   - Проверить запросы POST /scenarios и GET /scenarios/{id}/gantt
   - Сравнить payload и response

4. ПРОВЕРИТЬ ХРАНИЛИЩЕ:
   - InMemoryRepository хранит данные в памяти
   - При перезапуске сервера данные теряются
   - Убедиться, что используете один и тот же сервер

5. ПРОВЕРИТЬ ЧАСОВОЙ ПОЯС СЕРВЕРА:
   - На сервере: python -c "import datetime; print(datetime.datetime.now())"
   - На сервере: python -c "import pytz; print(pytz.timezone('Europe/Moscow').localize(datetime.datetime.now()))"


================================================================================
КЛЮЧЕВЫЕ ФАЙЛЫ И СТРОКИ
================================================================================

web/app.js:
  - Строки 4-33: Функции работы с датами (MOSCOW_TIMEZONE, parseIsoLike, getMoscowDayOfWeek)
  - Строки 35-48: getApiBaseUrl() - получение API URL
  - Строки 2615-2708: compilePayload() - подготовка данных для отправки
  - Строки 2710-2795: createScenario() - создание сценария
  - Строки 2797-2835: solveScenario() - решение сценария
  - Строки 2895-2980: loadSchedule() - загрузка расписания
  - Строки 2867-2892: formatTime(), formatDate() - форматирование для отображения

theater_sched/api/main.py:
  - Строки 11-12: MOSCOW_TZ = pytz.timezone('Europe/Moscow')
  - Строки 15-27: _normalize_date_and_dow() - нормализация даты и дня недели
  - Строки 30-40: _normalize_timeslot() - нормализация таймслота
  - Строки 43-53: _normalize_fixed_assignment() - нормализация закреплённых показов
  - Строки 172-189: POST /scenarios - создание сценария
  - Строки 197-229: POST /scenarios/{id}/solve - решение
  - Строки 257-315: GET /scenarios/{id}/gantt - получение расписания для Ганта
  - Строки 273-282: to_iso() - преобразование даты/времени в ISO формат

theater_sched/solver/cp_sat_solver.py:
  - Строки 166-167: MOSCOW_TZ = pytz.timezone('Europe/Moscow')
  - Строки 169-187: get_week_key() - вычисление ключа недели
  - Строка 119: Сортировка таймслотов по (date, start_time)


================================================================================
ВОЗМОЖНЫЕ ИСТОЧНИКИ ПРОБЛЕМ
================================================================================

1. НЕСООТВЕТСТВИЕ day_of_week:
   - Фронт вычисляет через Intl.DateTimeFormat
   - Бэк пересчитывает через pytz + weekday()
   - Если результаты различаются -> расписание строится неправильно

2. НЕПРАВИЛЬНЫЙ ПАРСИНГ ДАТЫ:
   - datetime.fromisoformat() может интерпретировать дату по-разному
   - В зависимости от того, как создан naive datetime

3. ПРОБЛЕМЫ С ISO ФОРМАТОМ:
   - Бэк возвращает ISO строку с часовым поясом (+03:00)
   - Фронт должен правильно парсить эту строку
   - Если парсинг неправильный -> время отображается неверно

4. ПРОБЛЕМЫ С СОРТИРОВКОЙ:
   - Если даты не в формате YYYY-MM-DD, сортировка может быть неправильной
   - Это влияет на логику "подряд идущих показов"

5. ПРОБЛЕМЫ С ГРУППИРОВКОЙ ВЫХОДНЫХ:
   - get_week_key() вычисляет номер недели
   - Если day_of_week неправильный, группировка может быть неверной

================================================================================







